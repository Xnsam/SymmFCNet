
require 'torch'
require 'nn'
require 'cudnn'
require 'cunn'
require 'nngraph'
require 'optim'
util = paths.dofile('util/util.lua')
require 'image'
require 'stn'
require 'lib/Binary'

opt = {
    DATA_ROOT = './TestDatasets',
    batchSize = 1,            -- # images in batch
    loadSize = 256,           -- scale images to this size
    fineSize = 256,           --  then crop to this size
    flip= 0,                  -- horizontal mirroring data augmentation
    gpu = 1,                  -- must GPU mode (cpu untested)
    phase = 'IrregularHoles', -- test dataset name        i.e., IrregularHoles, RegularHoles or RealImages
    preprocess = 'regular',   -- for special purpose preprocessing, e.g., for colorization, change this (selects preprocessing functions in util.lua)
    name = 'TestResults',     -- name of experiment, selects which model to run, should generally should be passed on command line
    input_nc = 17,            -- #  of input image channels
    output_nc = 3,            -- #  of output image channels
    serial_batches = 1,       -- if 1, takes images in order to make batches, otherwise takes them randomly
    serial_batch_iter = 1,    -- iter into serial image list
    cudnn = 1,                -- set to 0 to not use cudnn (untested)
    checkpoints_dir = './checkpoints', -- loads models from here
    results_dir='./results',                      -- saves results here
    masknet_path = './checkpoints/MaskNet.t7',    -- MaskNet path
    flownet_path = './checkpoints/FlowNet.t7',    -- FlowNet path
    lightnet_path = './checkpoints/LightNet.t7',  -- LightNet path
    recnet_path = './checkpoints/RecNet.t7',      -- RecNet path

}

----load model
netMask = util.load(opt.masknet_path,opt)
netFlow = util.load(opt.flownet_path,opt)
netLight= util.load(opt.lightnet_path,opt)
netRec =  util.load(opt.recnet_path,opt) 

opt.netG_name = opt.name .. '/' .. 'Completion'

for k,v in pairs(opt) do opt[k] = tonumber(os.getenv(k)) or os.getenv(k) or opt[k] end
opt.nThreads = 1 -- test only works with 1 thread...
print(opt)


opt.manualSeed = torch.random(1, 10000) -- set seed
print("Random Seed: " .. opt.manualSeed)
torch.manualSeed(opt.manualSeed)
torch.setdefaulttensortype('torch.FloatTensor')
local data_loader = paths.dofile('data_test/dataC.lua')
print('#threads...' .. opt.nThreads)
local data = data_loader.new(opt.nThreads, opt)
print("Dataset Size: ", data:size())
opt.how_many=data:size()
---------------------------------------------------------------------------------------------------

local real_maskimg = torch.Tensor(opt.batchSize, 3, opt.fineSize, opt.fineSize) -- add mask region
local real_mask = torch.Tensor(opt.batchSize, 3, opt.fineSize, opt.fineSize) -- binary mask
local real_groundtruth = torch.Tensor(opt.batchSize, 3, opt.fineSize, opt.fineSize) -- binary mask
local real_maskimgflip = torch.Tensor(opt.batchSize, 3, opt.fineSize, opt.fineSize) -- mask image flip
local warp_fusion = torch.Tensor(opt.batchSize, 3, opt.fineSize, opt.fineSize) -- 
local noise_mask = torch.Tensor(opt.batchSize,1,opt.fineSize,opt.fineSize)
local ShowNoiseMask = torch.Tensor(opt.batchSize,3,opt.fineSize,opt.fineSize)
local onesmatrix = torch.Tensor(real_maskimg:size()):fill(1)
local LightImg = torch.Tensor(opt.batchSize,3,opt.fineSize,opt.fineSize)
local ShowWarpNoiseMask = torch.Tensor(opt.batchSize,3,opt.fineSize,opt.fineSize)
local NoiseMaskNoGaussian = torch.Tensor(opt.batchSize,3,opt.fineSize,opt.fineSize)
local NoiseMaskFlipNoGaussian = torch.Tensor(opt.batchSize,3,opt.fineSize,opt.fineSize)

local PredictMask = torch.Tensor(opt.batchSize,3,opt.fineSize,opt.fineSize) -- generated by maskNet
local interpolation_img = torch.Tensor(opt.batchSize,3,opt.fineSize,opt.fineSize)
local FinalMask = torch.Tensor(opt.batchSize,3,opt.fineSize,opt.fineSize)

local filepaths = {} -- 
local filenames ={}
function TableConcat(t1,t2)
    for i=1,#t2 do
        t1[#t1+1] = t2[i]
    end
    return t1
end
local data_tm = torch.Timer()
for n=1,math.floor(opt.how_many/opt.batchSize) do 
    print('processing batch ' .. n)
    
    local real_data, filepaths_curr, _, _ = data:getBatch()
    local imgname2 = filepaths_curr[1]
    filepaths_curr = util.basename_batch(filepaths_curr)
    print('filepaths_curr: ', filepaths_curr)
    real_maskimg=real_data[{ {}, {1,3}, {}, {} }]:clone()
    real_maskimgflip=real_data[{ {}, {4,6}, {}, {} }]:clone() 
    real_mask=real_data[{ {}, {7,9}, {}, {} }]:clone() 
    real_groundtruth=real_data[{ {}, {10,12}, {}, {} }]:clone() 
    noise_mask = real_data[{{},{17},{},{}}]:clone() 
    noise_mask_flip = real_data[{{},{18},{},{}}]:clone() 
    noise_mask_no_gaussian = real_data[{{},{19},{},{}}]:clone() 
    noise_mask_flip_no_gaussian = real_data[{{},{20},{},{}}]:clone() 

    torch.manualSeed(os.time())

    ShowNoiseMask:zero()

    for i=1,opt.batchSize do
       
        ShowNoiseMask[i][1]:copy(noise_mask[i][1])
        ShowNoiseMask[i][2]:copy(noise_mask[i][1])
        ShowNoiseMask[i][3]:copy(noise_mask[i][1])

        NoiseMaskNoGaussian[i][1]:copy(noise_mask_no_gaussian[i][1])
        NoiseMaskNoGaussian[i][2]:copy(noise_mask_no_gaussian[i][1])
        NoiseMaskNoGaussian[i][3]:copy(noise_mask_no_gaussian[i][1])

        NoiseMaskFlipNoGaussian[i][1]:copy(noise_mask_flip_no_gaussian[i][1])
        NoiseMaskFlipNoGaussian[i][2]:copy(noise_mask_flip_no_gaussian[i][1])
        NoiseMaskFlipNoGaussian[i][3]:copy(noise_mask_flip_no_gaussian[i][1])

    end

    local outputMask = netMask:forward(real_maskimg:cuda())
    PredictMask = outputMask:clone()

    ----FlowNet
    local outputFlow = netFlow:forward({real_maskimg:cuda(),real_maskimgflip:cuda(),NoiseMaskNoGaussian:cuda(),NoiseMaskFlipNoGaussian:cuda(),PredictMask:cuda(),onesmatrix:cuda()})
    interpolation_img = outputFlow[2]:clone()
    ShowWarpNoiseMask = outputFlow[4]:clone() --noise mask flip warp

    ---LightNet
    local outputLight = netLight:forward({real_maskimg:cuda(),real_maskimgflip:cuda(),interpolation_img:cuda(),PredictMask:cuda(),NoiseMaskNoGaussian:cuda(),ShowWarpNoiseMask:cuda(),onesmatrix:cuda()})

    LightNetOutImg = outputLight[4]:clone()

    ------RecNet
    local outputRec = netRec:forward({LightNetOutImg:cuda(),PredictMask:cuda(),NoiseMaskNoGaussian:cuda(),ShowWarpNoiseMask:cuda(),onesmatrix:cuda()}) ---ours3

    RecOut = outputRec[1]:clone()
    FinalMask = outputRec[4]:clone()
    FinalResults = RecOut:float():clone():cmul(ShowNoiseMask:float())+real_maskimg:float():clone():cmul(1-ShowNoiseMask:float())
    

    ------------------create save files------
    paths.mkdir(paths.concat(opt.results_dir, opt.netG_name .. '_' .. opt.phase))
    local image_dir = paths.concat(opt.results_dir, opt.netG_name .. '_' .. opt.phase, 'images')
    paths.mkdir(image_dir)
    paths.mkdir(paths.concat(image_dir,'maskimg')) 
    paths.mkdir(paths.concat(image_dir,'groundtruth'))
    paths.mkdir(paths.concat(image_dir,'rec_finalout'))

    real_maskimg = real_groundtruth:clone():cmul(1-real_mask)+real_mask
    real_maskimg = util.deprocess_batch(real_maskimg):float()
    real_groundtruth = util.deprocess_batch(real_groundtruth):float()
    FinalResults = util.deprocess_batch(FinalResults):float()
    ------------------save image file -----
    for i=1, opt.batchSize do
        image.save(paths.concat(image_dir,'maskimg',filepaths_curr[i]), real_maskimg[i])
        image.save(paths.concat(image_dir,'groundtruth',filepaths_curr[i]), real_groundtruth[i])
        image.save(paths.concat(image_dir,'rec_finalout',filepaths_curr[i]), FinalResults[i])
    end
    print('Saved images to: ', image_dir)
    BB=string.split(imgname2,'/')
    local iename = BB[#BB]
    local ImgName={}
    ImgName[1]=iename
    filepaths = TableConcat(filepaths, filepaths_curr)
    filenames = TableConcat(filenames, ImgName)
end
-- make webpage
io.output(paths.concat(opt.results_dir,opt.netG_name .. '_' .. opt.phase, 'index.html'))
io.write('<meta http-equiv="Content-Type" content="tet/html;charset=UTF-8"><table style="text-align:center;">')
io.write('<tr><td>Image #</td><td>Occluded Image</td><td>Final Completion Results</td><td>Groundtruth</td></tr>')

for i=1, #filepaths do
    io.write('<tr>')
    io.write('<td>' .. filenames[i] .. '</td>')
    io.write('<td><img src="./images/maskimg/' .. filepaths[i] .. '"/></td>')
    io.write('<td><img src="./images/rec_finalout/' .. filepaths[i] .. '"/></td>')--
    io.write('<td><img src="./images/groundtruth/' .. filepaths[i] .. '"/></td>')
    io.write('</tr>')
end
io.write('</table>')
